/**
 * Content Diversifier
 * Ensures unique content and images for each post generated by automation
 */

document.addEventListener('DOMContentLoaded', function() {
    console.log('Content Diversifier loaded');
    
    // Override content generation and image selection functions
    overrideContentGeneration();
    
    // Fix existing content duplicates if viewing the blog
    if (window.location.href.includes('blog.html')) {
        setTimeout(diversifyExistingContent, 800);
    }
});

/**
 * Override content generation functions
 */
function overrideContentGeneration() {
    // Override the generateContent function if it exists
    if (typeof window.generateContent === 'function') {
        window.originalGenerateContent = window.generateContent;
        
        window.generateContent = async function(title, contentType) {
            console.log('Generating unique content for:', title);
            
            // Get original content
            const baseContent = await window.originalGenerateContent(title, contentType);
            
            // If no content generated, return base content
            if (!baseContent) return baseContent;
            
            // Get existing posts to check for duplicates
            const posts = JSON.parse(localStorage.getItem('fooodis-blog-posts') || '[]');
            
            // If this is the first post or no duplicate content, return as is
            if (posts.length === 0 || !contentIsDuplicate(baseContent, posts)) {
                return baseContent;
            }
            
            // Content is duplicate, generate a unique variant
            console.log('Detected duplicate content, generating unique variant');
            return makeContentUnique(baseContent, title, contentType);
        };
        
        console.log('Successfully overrode generateContent function');
    }
    
    // Override the post generation function for image uniqueness
    if (typeof window.generatePostFromPath === 'function') {
        // Only override if not already done by another fix
        if (!window.originalGeneratePostFromPath) {
            window.originalGeneratePostFromPath = window.generatePostFromPath;
        }
        
        window.generatePostFromPath = async function(path) {
            console.log('Content diversifier: Generating post for path:', path.name);
            
            try {
                // Generate title
                const title = await window.generateTitle(path.contentType);
                if (!title) {
                    return { success: false, error: 'Failed to generate title' };
                }
                
                // Generate UNIQUE content
                const content = await window.generateContent(title, path.contentType);
                if (!content) {
                    return { success: false, error: 'Failed to generate content' };
                }
                
                // Get existing posts to ensure we don't use the same image
                const existingPosts = JSON.parse(localStorage.getItem('fooodis-blog-posts') || '[]');
                const usedImages = existingPosts.map(post => post.image || post.imageUrl);
                
                // Get a unique image
                let imageUrl;
                
                if (path.useRandomImages) {
                    console.log('Using random image selection (but ensuring uniqueness)');
                    imageUrl = await getUniqueRandomImage(path.contentType, usedImages);
                } else if (path.mediaFolder) {
                    console.log('Using image from specified folder:', path.mediaFolder);
                    imageUrl = await getUniqueImageFromFolder(path.mediaFolder, usedImages);
                } else {
                    console.log('No folder specified, using default image selection with uniqueness check');
                    imageUrl = await getUniqueRandomImage(path.contentType, usedImages);
                }
                
                if (!imageUrl) {
                    console.warn('Failed to get unique image, using placeholder');
                    imageUrl = getPlaceholderImage(path.contentType);
                }
                
                // Create post object
                const post = {
                    id: 'post-' + Date.now(),
                    title: title,
                    content: content,
                    image: imageUrl,
                    imageUrl: imageUrl, // Set both for compatibility
                    author: 'AI Assistant',
                    date: new Date().toISOString(),
                    status: 'draft',
                    category: path.category || 'Uncategorized',
                    tags: path.tags || [],
                    mediaFolder: path.mediaFolder,
                    useRandomImages: path.useRandomImages,
                    generatedBy: path.id,
                    generatedAt: new Date().toISOString()
                };
                
                // Update path generation count
                updatePathGenerationCount(path);
                
                return { success: true, post: post };
            } catch (error) {
                console.error('Error generating post:', error);
                return { success: false, error: error.message || 'Unknown error' };
            }
        };
        
        console.log('Successfully overrode generatePostFromPath function for content diversity');
    }
}

/**
 * Check if content is a duplicate of existing posts
 * @param {string} content - The content to check
 * @param {Array} posts - Existing posts to check against
 * @returns {boolean} - True if duplicate, false if unique
 */
function contentIsDuplicate(content, posts) {
    // Remove common elements like titles that might differ
    const normalizedContent = normalizeContent(content);
    
    // Check against each existing post
    for (const post of posts) {
        if (!post.content) continue;
        
        const normalizedPostContent = normalizeContent(post.content);
        
        // Check for high similarity
        const similarity = calculateSimilarity(normalizedContent, normalizedPostContent);
        if (similarity > 0.85) { // 85% similarity threshold
            return true;
        }
    }
    
    return false;
}

/**
 * Normalize content by removing common patterns and noise
 * @param {string} content - Content to normalize
 * @returns {string} - Normalized content
 */
function normalizeContent(content) {
    return content
        .replace(/# Food Recipe Cooking ## Introduction Welcome to our latest blog post about Food!.*/g, '')
        .replace(/Today we're exploring the wonderful.*/g, '')
        .replace(/\s+/g, ' ')
        .trim()
        .toLowerCase();
}

/**
 * Calculate similarity between two strings
 * @param {string} str1 - First string
 * @param {string} str2 - Second string
 * @returns {number} - Similarity score between 0 and 1
 */
function calculateSimilarity(str1, str2) {
    // Simple Jaccard similarity on words
    const words1 = new Set(str1.split(/\s+/));
    const words2 = new Set(str2.split(/\s+/));
    
    const intersection = new Set([...words1].filter(x => words2.has(x)));
    const union = new Set([...words1, ...words2]);
    
    return intersection.size / union.size;
}

/**
 * Make content unique by adding variations
 * @param {string} baseContent - Original content
 * @param {string} title - Post title
 * @param {string} contentType - Content type
 * @returns {string} - Unique content
 */
function makeContentUnique(baseContent, title, contentType) {
    // Get the title without "The Ultimate Guide to" or similar prefixes
    const titleCore = title
        .replace(/The Ultimate Guide to /g, '')
        .replace(/\d+ Amazing Facts About /g, '')
        .replace(/Why /g, '')
        .replace(/ Is Trending in \d+/g, '');
    
    // Generate unique paragraphs based on title and content type
    const uniqueParagraphs = generateUniqueParagraphs(titleCore, contentType);
    
    // Find a good split point in the content
    const splitIndex = baseContent.indexOf('\n\n', baseContent.length * 0.3);
    
    if (splitIndex === -1) {
        // If can't find a good split point, just append the unique content
        return baseContent + '\n\n' + uniqueParagraphs;
    }
    
    // Insert unique paragraphs at the split point
    return baseContent.substring(0, splitIndex) + 
           '\n\n' + uniqueParagraphs + '\n\n' + 
           baseContent.substring(splitIndex);
}

/**
 * Generate unique paragraphs based on topic and type
 * @param {string} topic - Core topic
 * @param {string} type - Content type
 * @returns {string} - Unique paragraphs
 */
function generateUniqueParagraphs(topic, type) {
    // Generate a timestamp to ensure uniqueness
    const timestamp = Date.now().toString().slice(-6);
    
    // Create a set of template paragraphs based on content type
    const templates = {
        recipe: [
            `When working with ${topic}, it's important to consider how different cooking methods affect the final result. Some chefs prefer to use high heat for a shorter time, while others advocate for slow cooking to develop deeper flavors.`,
            `${topic} has gained popularity in recent years due to its versatility and unique flavor profile. It works well in both traditional recipes and modern fusion cuisine.`,
            `The history of ${topic} dates back many centuries, with variations found across different cultures and cuisines. Understanding these historical contexts can enhance your appreciation of this remarkable ingredient or dish.`
        ],
        review: [
            `${topic} restaurants have been evolving their approach to service in recent years. The best establishments now focus on creating a complete sensory experience rather than simply serving food.`,
            `When evaluating a ${topic} dining establishment, it's important to consider not just the food quality but also atmosphere, service efficiency, and value proposition.`,
            `The growing trend of ${topic} cuisine has led to an increase in specialized restaurants focusing on authentic preparations and techniques.`
        ],
        general: [
            `Industry experts have noted that ${topic} represents an important trend in the culinary world, with significant implications for restaurant management and food service.`,
            `Successful implementation of ${topic} strategies requires careful planning and consistent execution. The most successful restaurants understand this balance.`,
            `Recent market research suggests that consumer interest in ${topic} continues to grow, presenting both opportunities and challenges for restaurant owners.`
        ]
    };
    
    // Get the appropriate templates
    const typeTemplates = templates[type] || templates.general;
    
    // Select one template and customize it
    const selectedTemplate = typeTemplates[Math.floor(Math.random() * typeTemplates.length)];
    
    // Add unique identifier to ensure content is different
    return selectedTemplate + `\n\nUnique insight #${timestamp}: When implementing ${topic} in your restaurant or culinary practice, consider starting with small experiments before full adoption. This approach allows you to gauge customer response and fine-tune your offering.`;
}

/**
 * Get a unique random image that hasn't been used
 * @param {string} contentType - Content type
 * @param {Array} usedImages - Array of already used image URLs
 * @returns {Promise<string>} - Unique image URL
 */
async function getUniqueRandomImage(contentType, usedImages) {
    // Placeholder images pool
    const placeholdersByType = {
        recipe: [
            'images/placeholder-recipe-1.jpg',
            'images/placeholder-recipe-2.jpg',
            'images/placeholder-recipe-3.jpg'
        ],
        review: [
            'images/placeholder-restaurant-1.jpg',
            'images/placeholder-restaurant-2.jpg',
            'images/placeholder-restaurant-3.jpg'
        ],
        general: [
            'images/placeholder-food-1.jpg',
            'images/placeholder-food-2.jpg',
            'images/placeholder-food-3.jpg'
        ]
    };
    
    // Additional sample images
    const sampleImages = [
        'images/New images/restaurant-chilling-out-classy-lifestyle-reserved-2025-02-10-13-23-53-utc.jpg',
        'images/New images/restaurant-interior-design-empty-cafe-glasses-2025-02-13-14-58-26-utc.jpg',
        'images/New images/modern-fine-dining-setting-with-candles-high-table-2025-02-18-00-02-11-utc.jpg',
        'images/New images/restaurant-staff-meeting-briefing-before-service-2025-03-01-22-20-44-utc.jpg',
        'images/New images/chef-decorating-gourmet-dish-with-tweezers-2025-03-02-03-57-30-utc.jpg',
        'images/New images/chef-preparing-vegetable-dish-commercial-kitchen-2025-03-04-01-38-29-utc.jpg',
        'images/New images/chef-woman-cooking-salad-restaurant-kitchen-healthy-2025-03-04-01-38-09-utc.jpg',
        'images/New images/restaurant-chef-garnishing-preparing-appetizer-serving-dinner-2025-03-04-01-38-28-utc.jpg'
    ];
    
    // Get placeholders for this content type
    const typePlaceholders = placeholdersByType[contentType] || placeholdersByType.general;
    
    // Combine all available images
    const allImages = [...typePlaceholders, ...sampleImages];
    
    // Filter out used images
    const availableImages = allImages.filter(img => !usedImages.includes(img));
    
    if (availableImages.length > 0) {
        // Return a random available image
        return availableImages[Math.floor(Math.random() * availableImages.length)];
    } else {
        // If all images are used, use a placeholder with a unique query parameter
        const timestamp = Date.now();
        return typePlaceholders[0] + `?t=${timestamp}`;
    }
}

/**
 * Get a unique image from a specific folder
 * @param {string} folderId - Folder ID
 * @param {Array} usedImages - Array of already used image URLs
 * @returns {Promise<string>} - Unique image URL
 */
async function getUniqueImageFromFolder(folderId, usedImages) {
    // Get all media from localStorage
    let mediaLibrary = [];
    try {
        const savedMedia = localStorage.getItem('fooodis-blog-media');
        if (savedMedia) {
            mediaLibrary = JSON.parse(savedMedia);
        }
    } catch (error) {
        console.error('Error loading media library:', error);
        return null;
    }
    
    // Filter media by folder
    let folderMedia = [];
    if (folderId === 'uncategorized') {
        folderMedia = mediaLibrary.filter(item => !item.folder || item.folder === 'uncategorized');
    } else {
        folderMedia = mediaLibrary.filter(item => item.folder === folderId);
    }
    
    console.log(`Found ${folderMedia.length} media items in folder ${folderId}`);
    
    // Filter to only include images
    const images = folderMedia.filter(item => item.type && item.type.startsWith('image/'));
    console.log(`Found ${images.length} images in folder ${folderId}`);
    
    if (images.length === 0) {
        console.log('No images in folder, returning null');
        return null;
    }
    
    // Filter out images that have been used
    const availableImages = images.filter(img => !usedImages.includes(img.url));
    console.log(`Found ${availableImages.length} unused images in folder ${folderId}`);
    
    if (availableImages.length > 0) {
        // Get a random unused image
        const randomIndex = Math.floor(Math.random() * availableImages.length);
        const selectedImage = availableImages[randomIndex];
        
        // Mark the image as used for future reference
        markImageAsUsed(selectedImage.id);
        
        console.log(`Selected unused image ${selectedImage.id} from folder ${folderId}`);
        return selectedImage.url;
    } else if (images.length > 0) {
        // All images have been used, select one with the oldest "used" date
        const sortedImages = [...images].sort((a, b) => {
            if (!a.usedDate) return -1;
            if (!b.usedDate) return 1;
            return new Date(a.usedDate) - new Date(b.usedDate);
        });
        
        const selectedImage = sortedImages[0];
        
        // Update the used date to current time
        markImageAsUsed(selectedImage.id);
        
        console.log(`All images used, selected least recently used image ${selectedImage.id}`);
        return selectedImage.url;
    }
    
    return null;
}

/**
 * Mark an image as used in automation
 * @param {string} imageId - Image ID
 */
function markImageAsUsed(imageId) {
    // Get all media from localStorage
    let mediaLibrary = [];
    try {
        const savedMedia = localStorage.getItem('fooodis-blog-media');
        if (savedMedia) {
            mediaLibrary = JSON.parse(savedMedia);
        }
    } catch (error) {
        console.error('Error loading media library:', error);
        return;
    }
    
    // Find the image
    const imageIndex = mediaLibrary.findIndex(item => item.id === imageId);
    
    if (imageIndex !== -1) {
        // Mark as used
        mediaLibrary[imageIndex].usedInAutomation = true;
        mediaLibrary[imageIndex].usedDate = new Date().toISOString();
        
        // Save back to localStorage
        localStorage.setItem('fooodis-blog-media', JSON.stringify(mediaLibrary));
        
        console.log(`Image ${imageId} marked as used in automation`);
    }
}

/**
 * Get a placeholder image based on content type
 * @param {string} contentType - Content type
 * @returns {string} - Placeholder image URL
 */
function getPlaceholderImage(contentType) {
    const placeholders = {
        recipe: 'images/placeholder-recipe-1.jpg',
        review: 'images/placeholder-restaurant-1.jpg',
        general: 'images/placeholder-food-1.jpg'
    };
    
    return placeholders[contentType] || placeholders.general;
}

/**
 * Update path generation count
 * @param {Object} path - Path object
 */
function updatePathGenerationCount(path) {
    if (!path || !path.id) return;
    
    // Get paths from localStorage
    let paths = [];
    try {
        const savedPaths = localStorage.getItem('aiAutomationPaths');
        if (savedPaths) {
            paths = JSON.parse(savedPaths);
        }
    } catch (error) {
        console.error('Error loading paths:', error);
        return;
    }
    
    // Find the path
    const pathIndex = paths.findIndex(p => p.id === path.id);
    if (pathIndex !== -1) {
        // Update generation count
        if (!paths[pathIndex].generationCount) {
            paths[pathIndex].generationCount = 0;
        }
        paths[pathIndex].generationCount++;
        paths[pathIndex].lastGenerated = new Date().toISOString();
        
        // Save back to localStorage
        localStorage.setItem('aiAutomationPaths', JSON.stringify(paths));
    }
}

/**
 * Diversify existing content for blog display
 */
function diversifyExistingContent() {
    console.log('Diversifying existing blog content');
    
    // Get all posts
    const posts = JSON.parse(localStorage.getItem('fooodis-blog-posts') || '[]');
    
    // Skip if no posts or only one post
    if (posts.length <= 1) {
        console.log('No posts or only one post, skipping content diversification');
        return;
    }
    
    // Track content similarity
    let contentChanged = false;
    const contentHashes = new Map();
    
    // Check each post for duplicate content
    posts.forEach((post, index) => {
        if (!post.content) return;
        
        // Normalize content for comparison
        const normalizedContent = normalizeContent(post.content);
        const contentHash = hashString(normalizedContent);
        
        // Check if this hash exists
        if (contentHashes.has(contentHash)) {
            console.log(`Post ${post.id} has duplicate content, diversifying`);
            
            // Make content unique
            post.content = makeContentUnique(post.content, post.title, getContentTypeFromPost(post));
            contentChanged = true;
            
            // Add new hash
            contentHashes.set(hashString(normalizeContent(post.content)), post.id);
        } else {
            // Add this content hash
            contentHashes.set(contentHash, post.id);
        }
    });
    
    // Save changes if any content was modified
    if (contentChanged) {
        localStorage.setItem('fooodis-blog-posts', JSON.stringify(posts));
        console.log('Saved diversified content to localStorage');
        
        // Refresh the page to show changes
        if (window.location.href.includes('blog.html')) {
            console.log('Refreshing page content with diversified posts');
            const postsGrid = document.getElementById('blogPostsGrid');
            if (postsGrid && typeof window.renderBlogPosts === 'function') {
                window.renderBlogPosts();
            }
        }
    }
}

/**
 * Simple string hashing function
 * @param {string} str - String to hash
 * @returns {string} - Hash value
 */
function hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    return hash.toString();
}

/**
 * Get content type from post
 * @param {Object} post - Post object
 * @returns {string} - Content type
 */
function getContentTypeFromPost(post) {
    if (!post) return 'general';
    
    if (post.category === 'Recipes' || post.title.includes('Recipe')) {
        return 'recipe';
    } else if (post.category === 'Reviews' || post.title.includes('Review') || post.title.includes('restaurant')) {
        return 'review';
    }
    
    return 'general';
}

// Make functions available globally
window.contentDiversifier = {
    makeContentUnique,
    getUniqueImageFromFolder,
    getUniqueRandomImage,
    diversifyExistingContent
};
